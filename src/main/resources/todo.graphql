type User
@size(max: 10000)
{
  user_id: ID
  username: String @selectivity(max: 10000)
  todos: [Todo] @inverse(field: "user") @multiplicity(max: 1000)
}

type Todo
@size(max: 100000)
#@selectivity(hints: [{
#    field: ["user.username", "status"], #If it isn't clear to the optimizer, we can hint here
#    max: 1000,
#    distribution: "zipf"
#  }]
#)
{
  todo_id: ID
  title: String
    @mutable
    @selectivity(max: 1000, distribution: "zipf")
  status: boolean
    @mutable
    @selectivity(max: 50000, distribution: "zipf")
  user: User! @inverse(field: "todos")
}

## Query & Mutation type must be after entity type

type Query
{
  #todo: no-directive does not parse.
  todosById: Todo @sql(where: todo_id = $todo_id)
  todosByUser: [Todo] @sql(where: user.username = $username)
  todosByTitle: [Todo] @sql(where: user.username = $username AND title = $title)
  todosByCompleted: [Todo] @sql(where: user.username = $username AND status = $status) #Assure we can do a partition scan easily
  user: [User] @sql(where: user_id = $user_id)
}

## Queries must come after all type definitions


query GetTodosById($todo_id: ID)
@sla(throughput_per_second: 1000, latency_ms: 10)
{
  todosById(todo_id: $todo_id) {
    title
    status
    user {
      user_id
    }
  }
  todosByCompleted(status: $status) {
    title
  }
}
query GetTodosByUser($username: String)
@sla(throughput_per_second: 100, latency_ms: 50)
{
  todosByUser(user_id: $user_id) {
    title
    status
    user {
      user_id
    }
  }
}
query GetTodosByTitle($username: String, $title: title)
@sla(throughput_per_second: 1, latency_ms: 1000)
{
  todosByTitle(user_id: $username, title: $title) {
    title
    status
    user {
      user_id
    }
  }
}
query GetUserByID($user_id: ID)
@sla(throughput_per_second: 10, latency_ms: 10)
 {
  user(user_id: $user_id) {
    title
    status
    user {
      user_id
    }
  }
}
